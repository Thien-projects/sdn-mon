/*
 * Copyright 2014-2016 Nippon Telegraph and Telephone Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.access_functions.conf 11358 2004-10-14 12:57:34Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "ifTable_type.h"
#include "dataplane_interface.h"

#include "ifTable_access.h"
#include "ifTable_enums.h"

#include "port_table_common.h"

netsnmp_variable_list *
ifTable_get_first_data_point(void **my_loop_context, void **my_data_context,
                             netsnmp_variable_list *put_index_data,
                             netsnmp_iterator_info *mydata) {
  lagopus_result_t ret = LAGOPUS_RESULT_ANY_FAILURES;
  struct port_table_loop_context *lctx;

  lagopus_msg_debug(25, "called\n");

  if (my_loop_context != NULL && my_data_context != NULL &&
      put_index_data != NULL) {
    if ((lctx = (struct port_table_loop_context *) malloc (sizeof(
                  *lctx))) != NULL) {
      if ((ret = dp_get_port_stat(&lctx->port_stat)) == LAGOPUS_RESULT_OK) {
        lctx->refcnt = 1;
        lctx->ifIndex = 0;
        lctx->index = 0;
        *my_loop_context = lctx;
        return ifTable_get_next_data_point(my_loop_context, my_data_context,
                                           put_index_data, mydata);
      } else {
        lagopus_msg_error("failed to get port_stat: %s\n",
                          lagopus_error_get_string(ret));
      }
      free(lctx);
    } else {
      lagopus_msg_error("failed to malloc\n");
    }
  } else {
    lagopus_msg_error("invalid arguments\n");
  }
  return NULL;
}

netsnmp_variable_list *
ifTable_get_next_data_point(void **my_loop_context,
                            void **my_data_context,
                            netsnmp_variable_list *put_index_data,
                            netsnmp_iterator_info *mydata) {
  struct port_table_loop_context *lctx;

  lagopus_msg_debug(25, "called\n");

  (void)mydata;
  if (my_loop_context == NULL || *my_loop_context == NULL ||
      my_data_context == NULL ||
      put_index_data == NULL) {
    return NULL;
  }

  lctx = (struct port_table_loop_context *)*my_loop_context;
  if (lctx->ifIndex < 0) {
    snmp_log(LOG_ERR, "invalid arguments\n");
    return NULL;
  }
  lctx->index = (size_t)(lctx->ifIndex);
  lctx->ifIndex = lctx->ifIndex + 1;

  lagopus_msg_debug(25, "ifIndex is %d\n", lctx->ifIndex);

  if (dataplane_interface_exist(lctx->port_stat, lctx->index) == true) {
    netsnmp_variable_list *vptr;
    struct port_table_data_context *dctx = NULL;
    if ((dctx = (struct port_table_data_context *)
                malloc (sizeof(*dctx))) != NULL) {
      dctx->lctx = lctx;
      lctx->refcnt++;
      dctx->index = lctx->index;
      dctx->ifIndex = lctx->ifIndex;
      vptr = put_index_data;
      snmp_set_var_value(vptr, (u_char *) &lctx->ifIndex,
                         sizeof(lctx->ifIndex));
      *my_data_context = (void *)dctx;
      *my_loop_context = (void *)lctx;
      return put_index_data;
    } else {
      lagopus_msg_error("failed to malloc\n");
    }
    free(dctx);
  }
  return NULL;
}

void
ifTable_data_free(void *data_context,
                  netsnmp_iterator_info *mydata) {
  (void)mydata;
  lagopus_msg_debug(25, "called\n");
  if (data_context != NULL) {
    struct port_table_data_context *dctx = data_context;
    struct port_table_loop_context *lctx = dctx->lctx;
    lctx->refcnt--;
    if (lctx->refcnt == 0) {
      port_stat_release(lctx->port_stat);
      free(lctx->port_stat);
      free(lctx);
    }

    free(dctx);
  }
  return;
}

void
ifTable_loop_free(void *loop_context,
                  netsnmp_iterator_info *mydata) {
  struct port_table_loop_context *lctx;
  lagopus_msg_debug(25, "called\n");
  (void)mydata;
  if (loop_context != NULL) {
    lctx = (struct port_table_loop_context *) loop_context;
    lctx->refcnt--;
    if (lctx->refcnt == 0) {
      port_stat_release(lctx->port_stat);
      free(lctx->port_stat);
      free(lctx);
    }
  }
  return;
}

int32_t *
get_ifIndex(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  if (data_context != NULL && ret_len != NULL) {
    struct port_table_data_context *dctx = (struct port_table_data_context *)
                                           data_context;
    struct ifTable_entry *entry = &dctx->entry;
    entry->ifIndex = dctx->ifIndex;
    *ret_len = sizeof(entry->ifIndex);
    return &entry->ifIndex;
  }
  return NULL;
}

char *
get_ifDescr(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  if (data_context != NULL && ret_len != NULL) {
    struct port_table_data_context *dctx = (struct port_table_data_context *)
                                           data_context;
    struct port_table_loop_context *lctx = dctx->lctx;
    struct ifTable_entry *entry = &dctx->entry;
    size_t len = IFNAMSIZ + 1;
    *ret_len = 0;
    if (dataplane_interface_get_ifDescr(
          lctx->port_stat,
          dctx->index,
          entry->ifDescr, &len) == LAGOPUS_RESULT_OK) {
      *ret_len = len;
      return entry->ifDescr;
    }
  }
  return NULL;
}

int32_t *
get_ifType(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  if (data_context != NULL && ret_len != NULL) {
    struct port_table_data_context *dctx = (struct port_table_data_context *)
                                           data_context;
    struct port_table_loop_context *lctx = dctx->lctx;
    struct ifTable_entry *entry = &dctx->entry;
    *ret_len = 0;
    if (dataplane_interface_get_ifType(
          lctx->port_stat,
          dctx->index,
          &entry->ifType) == LAGOPUS_RESULT_OK) {
      *ret_len = sizeof(entry->ifType);
      return &entry->ifType;
    }
  }
  return NULL;
}

int32_t *
get_ifMtu(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  if (data_context != NULL && ret_len != NULL) {
    struct port_table_data_context *dctx = (struct port_table_data_context *)
                                           data_context;
    struct port_table_loop_context *lctx = dctx->lctx;
    struct ifTable_entry *entry = &dctx->entry;
    *ret_len = 0;
    if (dataplane_interface_get_ifMtu(
          lctx->port_stat,
          dctx->index,
          &entry->ifMtu) == LAGOPUS_RESULT_OK) {
      *ret_len = sizeof(entry->ifMtu);
      return &entry->ifMtu;
    }
  }
  return NULL;
}

uint32_t *
get_ifSpeed(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  (void) data_context;
  (void) ret_len;
  if (data_context != NULL && ret_len != NULL) {
    struct port_table_data_context *dctx = (struct port_table_data_context *)
                                           data_context;
    struct port_table_loop_context *lctx = dctx->lctx;
    struct ifTable_entry *entry = &dctx->entry;
    *ret_len = 0;
    /* TODO implement this */
    if (dataplane_interface_get_ifSpeed(
          lctx->port_stat,
          dctx->index,
          &entry->ifSpeed) == LAGOPUS_RESULT_OK) {
      *ret_len = sizeof(entry->ifSpeed);
      return &entry->ifSpeed;
    }
  }
  return NULL;
}

char *
get_ifPhysAddress(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  if (data_context != NULL && ret_len != NULL) {
    struct port_table_data_context *dctx = (struct port_table_data_context *)
                                           data_context;
    struct port_table_loop_context *lctx = dctx->lctx;
    struct ifTable_entry *entry = &dctx->entry;
    size_t len;
    *ret_len = 0;
    if (dataplane_interface_get_ifPhysAddress(
          lctx->port_stat,
          dctx->index,
          entry->ifPhysAddress,
          &len) == LAGOPUS_RESULT_OK) {
      *ret_len = len;
      return entry->ifPhysAddress;
    }
  }
  return NULL;
}

int32_t *
get_ifAdminStatus(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  if (data_context != NULL && ret_len != NULL) {
    struct port_table_data_context *dctx = (struct port_table_data_context *)
                                           data_context;
    struct port_table_loop_context *lctx = dctx->lctx;
    struct ifTable_entry *entry = &dctx->entry;
    *ret_len = 0;
    if (dataplane_interface_get_ifAdminStatus(
          lctx->port_stat,
          dctx->index,
          &entry->ifAdminStatus) == LAGOPUS_RESULT_OK) {
      *ret_len = sizeof(entry->ifAdminStatus);
      return &entry->ifAdminStatus;
    }
  }
  return NULL;
}

int32_t *
get_ifOperStatus(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  if (data_context != NULL && ret_len != NULL) {
    struct port_table_data_context *dctx = (struct port_table_data_context *)
                                           data_context;
    struct port_table_loop_context *lctx = dctx->lctx;
    struct ifTable_entry *entry = &dctx->entry;
    *ret_len = 0;
    if (dataplane_interface_get_ifOperStatus(
          lctx->port_stat,
          dctx->index,
          &entry->ifOperStatus) == LAGOPUS_RESULT_OK) {
      *ret_len = sizeof(entry->ifOperStatus);
      return &entry->ifOperStatus;
    }
  }
  return NULL;
}

uint32_t *
get_ifLastChange(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  if (data_context != NULL && ret_len != NULL) {
    struct port_table_data_context *dctx = (struct port_table_data_context *)
                                           data_context;
    struct port_table_loop_context *lctx = dctx->lctx;
    struct ifTable_entry *entry = &dctx->entry;
    *ret_len = 0;
    if (dataplane_interface_get_ifLastChange(
          lctx->port_stat,
          dctx->index,
          &entry->ifLastChange) == LAGOPUS_RESULT_OK) {
      *ret_len = sizeof(entry->ifLastChange);
      return &entry->ifLastChange;
    }
  }
  return NULL;
}

uint32_t *
get_ifInOctets(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  if (data_context != NULL && ret_len != NULL) {
    struct port_table_data_context *dctx = (struct port_table_data_context *)
                                           data_context;
    struct port_table_loop_context *lctx = dctx->lctx;
    struct ifTable_entry *entry = &dctx->entry;
    *ret_len = 0;
    if (dataplane_interface_get_ifInOctets(
          lctx->port_stat,
          dctx->index,
          &entry->ifInOctets) == LAGOPUS_RESULT_OK) {
      *ret_len = sizeof(entry->ifInOctets);
      return &entry->ifInOctets;
    }
  }
  return NULL;
}

uint32_t *
get_ifInUcastPkts(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  if (data_context != NULL && ret_len != NULL) {
    struct port_table_data_context *dctx = (struct port_table_data_context *)
                                           data_context;
    struct port_table_loop_context *lctx = dctx->lctx;
    struct ifTable_entry *entry = &dctx->entry;
    *ret_len = 0;
    if (dataplane_interface_get_ifInUcastPkts(
          lctx->port_stat,
          dctx->index,
          &entry->ifInUcastPkts) == LAGOPUS_RESULT_OK) {
      *ret_len = sizeof(entry->ifInUcastPkts);
      return &entry->ifInUcastPkts;
    }
  }
  return NULL;
}

uint32_t *
get_ifInNUcastPkts(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  // deprecated
  if (data_context != NULL && ret_len != NULL) {
    (void)data_context;
    *ret_len = 0;
  }
  return NULL;
}

uint32_t *
get_ifInDiscards(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  if (data_context != NULL && ret_len != NULL) {
    struct port_table_data_context *dctx = (struct port_table_data_context *)
                                           data_context;
    struct port_table_loop_context *lctx = dctx->lctx;
    struct ifTable_entry *entry = &dctx->entry;
    *ret_len = 0;
    if (dataplane_interface_get_ifInDiscards(
          lctx->port_stat,
          dctx->index,
          &entry->ifInDiscards) == LAGOPUS_RESULT_OK) {
      *ret_len = sizeof(entry->ifInDiscards);
      return &entry->ifInDiscards;
    }
  }
  return NULL;
}

uint32_t *
get_ifInErrors(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  if (data_context != NULL && ret_len != NULL) {
    struct port_table_data_context *dctx = (struct port_table_data_context *)
                                           data_context;
    struct port_table_loop_context *lctx = dctx->lctx;
    struct ifTable_entry *entry = &dctx->entry;
    *ret_len = 0;
    if (dataplane_interface_get_ifInErrors(
          lctx->port_stat,
          dctx->index,
          &entry->ifInErrors) == LAGOPUS_RESULT_OK) {
      *ret_len = sizeof(entry->ifInErrors);
      return &entry->ifInErrors;
    }
  }
  return NULL;
}

uint32_t *
get_ifInUnknownProtos(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  // not supported
  (void)data_context;
  (void)ret_len;
  return NULL;
}

uint32_t *
get_ifOutOctets(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  if (data_context != NULL && ret_len != NULL) {
    struct port_table_data_context *dctx = (struct port_table_data_context *)
                                           data_context;
    struct port_table_loop_context *lctx = dctx->lctx;
    struct ifTable_entry *entry = &dctx->entry;
    *ret_len = 0;
    if (dataplane_interface_get_ifOutOctets(
          lctx->port_stat,
          dctx->index,
          &entry->ifOutOctets) == LAGOPUS_RESULT_OK) {
      *ret_len = sizeof(entry->ifOutOctets);
      return &entry->ifOutOctets;
    }
  }
  return NULL;
}

uint32_t *
get_ifOutUcastPkts(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  if (data_context != NULL && ret_len != NULL) {
    struct port_table_data_context *dctx = (struct port_table_data_context *)
                                           data_context;
    struct port_table_loop_context *lctx = dctx->lctx;
    struct ifTable_entry *entry = &dctx->entry;
    *ret_len = 0;
    if (dataplane_interface_get_ifOutUcastPkts(
          lctx->port_stat,
          dctx->index,
          &entry->ifOutUcastPkts) == LAGOPUS_RESULT_OK) {
      *ret_len = sizeof(entry->ifOutUcastPkts);
      return &entry->ifOutUcastPkts;
    }
  }
  return NULL;
}

uint32_t *
get_ifOutNUcastPkts(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  // deprecated
  if (data_context != NULL && ret_len != NULL) {
    (void)data_context;
    *ret_len = 0;
  }
  return NULL;
}

uint32_t *
get_ifOutDiscards(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  if (data_context != NULL && ret_len != NULL) {
    struct port_table_data_context *dctx = (struct port_table_data_context *)
                                           data_context;
    struct port_table_loop_context *lctx = dctx->lctx;
    struct ifTable_entry *entry = &dctx->entry;
    *ret_len = 0;
    if (dataplane_interface_get_ifOutDiscards(
          lctx->port_stat,
          dctx->index,
          &entry->ifOutDiscards) == LAGOPUS_RESULT_OK) {
      *ret_len = sizeof(entry->ifOutDiscards);
      return &entry->ifOutDiscards;
    }
  }
  return NULL;
}

uint32_t *
get_ifOutErrors(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  if (data_context != NULL && ret_len != NULL) {
    struct port_table_data_context *dctx = (struct port_table_data_context *)
                                           data_context;
    struct port_table_loop_context *lctx = dctx->lctx;
    struct ifTable_entry *entry = &dctx->entry;
    *ret_len = 0;
    if (dataplane_interface_get_ifOutErrors(
          lctx->port_stat,
          dctx->index,
          &entry->ifOutErrors) == LAGOPUS_RESULT_OK) {
      *ret_len = sizeof(entry->ifOutErrors);
      return &entry->ifOutErrors;
    }
  }
  return NULL;
}

uint32_t *
get_ifOutQLen(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  // deprecated
  if (data_context != NULL && ret_len != NULL) {
    (void)data_context;
    *ret_len = 0;
  }
  return NULL;
}

oid *
get_ifSpecific(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  if (data_context != NULL && ret_len != NULL) {
    // ifSpecific is deprecated. always return 0.0
    static oid ifSpecific_oid[] = {0,0};
    size_t ifSpecific_oid_len   = OID_LENGTH(ifSpecific_oid);
    (void)data_context;
    *ret_len = ifSpecific_oid_len;
    return ifSpecific_oid;
  }
  return NULL;
}
