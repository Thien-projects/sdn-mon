/*
 * Copyright 2014-2016 Nippon Telegraph and Telephone Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.iterate_access.conf 17483 2009-04-09 08:54:46Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "dot1dBasePortTable.h"
#include "dot1dBasePortTable_access.h"

/** Initialize the dot1dBasePortTable table by defining its contents and how it's structured */
void
initialize_table_dot1dBasePortTable(void) {
  static oid dot1dBasePortTable_oid[] = {1,3,6,1,2,1,17,1,4};
  netsnmp_table_registration_info *table_info;
  netsnmp_handler_registration *my_handler;
  netsnmp_iterator_info *iinfo;

  /** create the table registration information structures */
  table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
  iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

  my_handler = netsnmp_create_handler_registration("dot1dBasePortTable",
               dot1dBasePortTable_handler,
               dot1dBasePortTable_oid,
               OID_LENGTH(dot1dBasePortTable_oid),
               HANDLER_CAN_RONLY
                                                  );

  if (!my_handler || !table_info || !iinfo) {
    snmp_log(LOG_ERR, "malloc failed in initialize_table_dot1dBasePortTable");
    if (my_handler != NULL) {
      SNMP_FREE(my_handler);
    }
    if (table_info != NULL) {
      SNMP_FREE(table_info);
    }
    if (iinfo != NULL) {
      SNMP_FREE(iinfo);
    }
    return; /** Serious error. */
  }

  /***************************************************
   * Setting up the table's definition
   */
  netsnmp_table_helper_add_indexes(table_info,
                                   ASN_INTEGER, /** index: dot1dBasePort */
                                   0);

  /** Define the minimum and maximum accessible columns.  This
      optimizes retrival. */
  table_info->min_column = 1;
  table_info->max_column = 5;

  /** iterator access routines */
  iinfo->get_first_data_point = dot1dBasePortTable_get_first_data_point;
  iinfo->get_next_data_point = dot1dBasePortTable_get_next_data_point;

  /* iinfo->make_data_context = dot1dBasePortTable_context_convert_function; */
  iinfo->free_data_context = dot1dBasePortTable_data_free;

  /** pick *only* one of these if you use them */
  /* iinfo->free_loop_context = dot1dBasePortTable_loop_free; */
  iinfo->free_loop_context_at_end = dot1dBasePortTable_loop_free;

  /** tie the two structures together */
  iinfo->table_reginfo = table_info;

  /***************************************************
   * registering the table with the master agent
   */
  DEBUGMSGTL(("initialize_table_dot1dBasePortTable",
              "Registering table dot1dBasePortTable as a table iterator\n"));
  netsnmp_register_table_iterator(my_handler, iinfo);
}

/** Initializes the dot1dBasePortTable module */
void
init_dot1dBasePortTable(void) {

  /** here we initialize all the tables we're planning on supporting */
  initialize_table_dot1dBasePortTable();
}

/** handles requests for the dot1dBasePortTable table, if anything else needs to be done */
int
dot1dBasePortTable_handler(
  netsnmp_mib_handler               *handler,
  netsnmp_handler_registration      *reginfo,
  netsnmp_agent_request_info        *reqinfo,
  netsnmp_request_info              *requests) {

  netsnmp_request_info *request;
  netsnmp_table_request_info *table_info;
  netsnmp_variable_list *var;

  void *data_context = NULL;

  (void) reginfo;
  (void) handler;

  for (request = requests; request; request = request->next) {
    var = request->requestvb;
    if (request->processed != 0) {
      continue;
    }

    switch (reqinfo->mode) {
      case MODE_GET:
        data_context =  netsnmp_extract_iterator_context(request);
        if (data_context == NULL) {
          netsnmp_set_request_error(reqinfo, request,
                                    SNMP_NOSUCHINSTANCE);
          continue;
        }
        break;

    }

    /** extracts the information about the table from the request */
    table_info = netsnmp_extract_table_info(request);
    /** table_info->colnum contains the column number requested */
    /** table_info->indexes contains a linked list of snmp variable
        bindings for the indexes of the table.  Values in the list
        have been set corresponding to the indexes of the
        request */
    if (table_info == NULL) {
      continue;
    }

    switch (reqinfo->mode) {
      case MODE_GET:
        switch (table_info->colnum) {
          case COLUMN_DOT1DBASEPORT: {
            int32_t *retval;
            size_t retval_len = 0;
            retval = get_dot1dBasePort(data_context, &retval_len);
            if (retval)
              snmp_set_var_typed_value(var, ASN_INTEGER,
                                       (const u_char *) retval,
                                       retval_len);
          }
          break;

          case COLUMN_DOT1DBASEPORTIFINDEX: {
            int32_t *retval;
            size_t retval_len = 0;
            retval = get_dot1dBasePortIfIndex(data_context, &retval_len);
            if (retval)
              snmp_set_var_typed_value(var, ASN_INTEGER,
                                       (const u_char *) retval,
                                       retval_len);
          }
          break;

          case COLUMN_DOT1DBASEPORTCIRCUIT: {
            oid *retval;
            size_t retval_len = 0;
            retval = get_dot1dBasePortCircuit(data_context, &retval_len);
            if (retval)
              snmp_set_var_typed_value(var, ASN_OBJECT_ID,
                                       (const u_char *) retval,
                                       retval_len);
          }
          break;

          case COLUMN_DOT1DBASEPORTDELAYEXCEEDEDDISCARDS: {
            uint32_t *retval;
            size_t retval_len = 0;
            retval = get_dot1dBasePortDelayExceededDiscards(data_context, &retval_len);
            if (retval)
              snmp_set_var_typed_value(var, ASN_COUNTER,
                                       (const u_char *) retval,
                                       retval_len);
          }
          break;

          case COLUMN_DOT1DBASEPORTMTUEXCEEDEDDISCARDS: {
            uint32_t *retval;
            size_t retval_len = 0;
            retval = get_dot1dBasePortMtuExceededDiscards(data_context, &retval_len);
            if (retval)
              snmp_set_var_typed_value(var, ASN_COUNTER,
                                       (const u_char *) retval,
                                       retval_len);
          }
          break;

          default:
            /** We shouldn't get here */
            snmp_log(LOG_ERR,
                     "problem encountered in dot1dBasePortTable_handler: unknown column\n");
        }
        break;


      default:
        snmp_log(LOG_ERR,
                 "problem encountered in dot1dBasePortTable_handler: unsupported mode\n");
    }
  }


  return SNMP_ERR_NOERROR;
}
