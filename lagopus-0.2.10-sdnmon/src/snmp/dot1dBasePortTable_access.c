/*
 * Copyright 2014-2016 Nippon Telegraph and Telephone Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.access_functions.conf 11358 2004-10-14 12:57:34Z dts12 $
 */

#include <stdbool.h>
#include <stdint.h>

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "lagopus_apis.h"
#include "ifTable_type.h"
#include "ifTable_access.h"

#include "dot1dBasePortTable_access.h"
#include "dot1dBasePortTable_enums.h"

#include "dataplane_interface.h"

#include "port_table_common.h"

/** returns the first data point within the dot1dBasePortTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
dot1dBasePortTable_get_first_data_point(void **my_loop_context,
                                        void **my_data_context,
                                        netsnmp_variable_list *put_index_data,
                                        netsnmp_iterator_info *mydata) {
  lagopus_result_t ret = LAGOPUS_RESULT_ANY_FAILURES;
  struct port_table_loop_context *lctx;
  struct bridge_stat *bridge_stat;
  if (my_loop_context != NULL && my_data_context != NULL &&
      put_index_data != NULL) {
    if ((lctx = (struct port_table_loop_context *) malloc (sizeof(
                  *lctx))) != NULL) {
      if ((ret = dp_get_bridge_stat(&bridge_stat)) == LAGOPUS_RESULT_OK) {
        if ((ret = bridge_stat_get_port_stat(bridge_stat, 0,
                                             &lctx->port_stat)) == LAGOPUS_RESULT_OK) {
          lctx->refcnt = 1;
          lctx->ifIndex = 0;
          lctx->index = 0;
          *my_loop_context = lctx;
          bridge_stat_release(bridge_stat);
          free(bridge_stat);
          return dot1dBasePortTable_get_next_data_point(my_loop_context, my_data_context,
                 put_index_data, mydata);
        }
        bridge_stat_release(bridge_stat);
        free(bridge_stat);
      } else {
        lagopus_msg_error("failed to get port_stat: %s\n",
                          lagopus_error_get_string(ret));
      }
      free(lctx);
    } else {
      lagopus_msg_error("failed to malloc\n");
    }
  } else {
    lagopus_msg_error("invalid arguments\n");
  }
  return NULL;
}

struct dot1dBasePortTable_entry {
  /* Column values */
  int32_t dot1dBasePort;
  int32_t dot1dBasePortIfIndex;

  // TODO set a valid value if needed
  oid dot1dBasePortCircuit[10];

  size_t dot1dBasePortCircuit_len;
  uint32_t dot1dBasePortDelayExceededDiscards;
  uint32_t dot1dBasePortMtuExceededDiscards;

  /* Illustrate using a simple linked list */
  /* int   valid; */
  /* struct dot1dBasePortTable_entry *next; */
};

/** functionally the same as dot1dBasePortTable_get_first_data_point, but
    my_loop_context has already been set to a previous value and should
    be updated to the next in the list.  For example, if it was a
    linked list, you might want to cast it to your local data type and
    then return my_loop_context->next.  The my_data_context pointer
    should be set to something you need later and the indexes in
    put_index_data updated again. */
netsnmp_variable_list *
dot1dBasePortTable_get_next_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *put_index_data,
                                       netsnmp_iterator_info *mydata) {
  return ifTable_get_next_data_point(my_loop_context, my_data_context,
                                     put_index_data, mydata);
}

/** Create a data_context for non-existent rows that SETs are performed on.
 *  return a void * pointer which will be passed to subsequent get_XXX
 *  and set_XXX functions for data retrival and modification during
 *  this SET request.
 *
 *  The indexes are encoded (in order) into the index_data pointer,
 *  and the column object which triggered the row creation is available
 *  via the column parameter, if it would be helpful to use that information.
 */
void *
dot1dBasePortTable_create_data_context(netsnmp_variable_list *index_data,
                                       int column) {
  (void) index_data;
  (void) column;
  return NULL; /* XXX: you likely want to return a real pointer */
}

void
dot1dBasePortTable_data_free(void *data_context,
                             netsnmp_iterator_info *mydata) {
  ifTable_data_free(data_context, mydata);
}

void
dot1dBasePortTable_loop_free(void *loop_context,
                             netsnmp_iterator_info *mydata) {
  ifTable_loop_free(loop_context, mydata);
}

int32_t *
get_dot1dBasePort(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  if (data_context != NULL && ret_len != NULL) {
    struct port_table_data_context *dctx = (struct port_table_data_context *)
                                           data_context;
    struct ifTable_entry *entry = &dctx->entry;
    entry->ifIndex = dctx->ifIndex;
    *ret_len = sizeof(entry->ifIndex);
    return &entry->ifIndex;
  }
  return NULL;
}

int32_t *
get_dot1dBasePortIfIndex(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  if (data_context != NULL && ret_len != NULL) {
    struct port_table_data_context *dctx = (struct port_table_data_context *)
                                           data_context;
    struct port_table_loop_context *lctx = dctx->lctx;
    struct ifTable_entry *entry = &dctx->entry;
    size_t index;
    *ret_len = 0;
    if (dataplane_bridge_stat_get_port_ifIndex(
          lctx->port_stat,
          dctx->index,
          &index) == LAGOPUS_RESULT_OK) {
      *ret_len = sizeof(entry->dot1dBasePortIfIndex);
      entry->dot1dBasePortIfIndex = (int32_t)(index + 1);
      return &entry->dot1dBasePortIfIndex;
    }
  }
  return NULL;
}

oid *
get_dot1dBasePortCircuit(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  if (data_context != NULL && ret_len != NULL) {
    // always return 0.0
    static oid _oid[] = {0,0};
    size_t oid_len   = OID_LENGTH(_oid);
    (void)data_context;
    *ret_len = oid_len;
    return _oid;
  }
  return NULL;
}

uint32_t *
get_dot1dBasePortDelayExceededDiscards(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  if (data_context != NULL && ret_len != NULL) {
    struct port_table_data_context *dctx = (struct port_table_data_context *)
                                           data_context;
    struct port_table_loop_context *lctx = dctx->lctx;
    struct ifTable_entry *entry = &dctx->entry;
    *ret_len = 0;
    if (dataplane_interface_get_DelayExceededDiscards(
          lctx->port_stat,
          lctx->index,
          &entry->dot1dBasePortDelayExceededDiscards) == LAGOPUS_RESULT_OK) {
      *ret_len = sizeof(entry->dot1dBasePortDelayExceededDiscards);
      return &entry->dot1dBasePortDelayExceededDiscards;
    }
  }
  return NULL;
}

uint32_t *
get_dot1dBasePortMtuExceededDiscards(void *data_context, size_t *ret_len) {
  lagopus_msg_debug(25, "called\n");
  if (data_context != NULL && ret_len != NULL) {
    struct port_table_data_context *dctx = (struct port_table_data_context *)
                                           data_context;
    struct port_table_loop_context *lctx = dctx->lctx;
    struct ifTable_entry *entry = &dctx->entry;
    *ret_len = 0;
    if (dataplane_interface_get_MtuExceededDiscards(
          lctx->port_stat,
          lctx->index,
          &entry->dot1dBasePortMtuExceededDiscards) == LAGOPUS_RESULT_OK) {
      *ret_len = sizeof(entry->dot1dBasePortMtuExceededDiscards);
      return &entry->dot1dBasePortMtuExceededDiscards;
    }
  }
  return NULL;
}
